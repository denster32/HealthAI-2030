import Foundation
import Combine
import HealthKit // For HealthKit data types if needed
import SwiftData

/// Represents the Digital Twin, a dynamic, predictive model of a user's health.
///
/// - Central repository for all data related to the twin, including biometric, genomic, clinical, lifestyle, and environmental data.
/// - Used for analytics, predictions, and personalized recommendations.
@Model
class DigitalTwin {
    @Attribute(.unique) var id: UUID
    var userID: String
    var creationDate: Date
    var lastUpdated: Date
    var healthProfile: Data? // Serialized health data
    var predictiveModelVersion: String
    @Relationship(deleteRule: .cascade) var healthDataEntries: [HealthDataEntry]?

    init(id: UUID = UUID(), userID: String, creationDate: Date = Date(), lastUpdated: Date = Date(), healthProfile: Data? = nil, predictiveModelVersion: String = "1.0") {
        self.id = id
        self.userID = userID
        self.creationDate = creationDate
        self.lastUpdated = lastUpdated
        self.healthProfile = healthProfile
        self.predictiveModelVersion = predictiveModelVersion
    }

    // MARK: - Core Data Components
    /// High-resolution biometric data.
    var biometricData: BiometricProfile
    /// Genomic data profile (optional and user-provided).
    var genomicData: GenomicProfile?
    /// Clinical data from EHRs and lab results.
    var clinicalData: ClinicalProfile?
    /// Lifestyle data including nutrition, exercise, and sleep.
    var lifestyleData: LifestyleProfile
    /// Environmental data context.
    var environmentalContext: EnvironmentalProfile
    /// Health predictions generated by the Pre-Symptomatic Analytics Core.
    var healthPredictions: [HealthPrediction]

    // MARK: - Computed Properties for Risk Scores and Health Summaries
    var overallHealthScore: Double {
        // A composite score based on various health metrics
        // This would involve a more complex calculation in a real scenario
        let biometricScore = (biometricData.restingHeartRate.last ?? 70.0) < 70 ? 0.3 : 0.1
        let lifestyleScore = (lifestyleData.averageSleepDuration > 7 * 3600 && lifestyleData.weeklyExerciseMinutes > 150) ? 0.4 : 0.2
        let predictionScore = healthPredictions.first?.riskLevel == .low ? 0.3 : 0.1
        return min(1.0, biometricScore + lifestyleScore + predictionScore) * 100
    }

    var riskSummary: String {
        if healthPredictions.isEmpty {
            return "No immediate health risks detected."
        }
        let highRiskPredictions = healthPredictions.filter { $0.riskLevel == .high }
        if !highRiskPredictions.isEmpty {
            return "High risk detected for: \(highRiskPredictions.map { $0.type.rawValue }.joined(separator: ", ")). Consult a doctor."
        }
        return "Low to moderate health risks. Continue monitoring."
    }

    // MARK: - Methods for Updating and Merging Twin Data

    /// Updates the digital twin with new health data entries.
    func update(with healthDataEntries: [HealthDataEntry]) {
        for entry in healthDataEntries {
            switch entry.dataType {
            case .heartRate:
                biometricData.heartRate.append(entry.value)
            case .heartRateVariability:
                biometricData.heartRateVariability.append(entry.value)
            case .oxygenSaturation:
                biometricData.bloodOxygenSaturation.append(entry.value)
            case .sleepDuration:
                lifestyleData.sleepDurations.append(entry.value)
            case .steps:
                lifestyleData.dailySteps.append(Int(entry.value))
            case .caloriesBurned:
                lifestyleData.caloriesBurned.append(entry.value)
            case .environmentalAirQuality:
                environmentalContext.airQualityReadings.append(Int(entry.value))
            case .environmentalPollen:
                environmentalContext.pollenCounts.append(Int(entry.value))
            // Add more cases for other data types
            default:
                break // Handle other data types or log a warning
            }
        }
        self.lastUpdated = Date()
    }

    /// Merges another digital twin's data into this twin.
    func merge(with otherTwin: DigitalTwin) {
        self.biometricData.merge(with: otherTwin.biometricData)
        self.lifestyleData.merge(with: otherTwin.lifestyleData)
        self.environmentalContext.merge(with: otherTwin.environmentalContext)
        self.healthPredictions.append(contentsOf: otherTwin.healthPredictions)
        self.lastUpdated = Date()
        // More sophisticated merging logic would be needed for genomic and clinical data
    }

    /// Generates new health predictions based on the current state of the twin.
    func generatePredictions() {
        // This is a placeholder for actual predictive modeling.
        // In a real system, this would involve calling a CoreML model or a backend AI service.
        let newPrediction = HealthPrediction(
            type: .cardiovascularDisease,
            riskLevel: Double.random(in: 0...1) > 0.8 ? .high : .low,
            confidence: 0.9,
            timestamp: Date(),
            details: "Based on current biometric and lifestyle trends."
        )
        self.healthPredictions.append(newPrediction)
    }

    /// Calculates and updates the overall health score and risk assessments.
    func updateHealthScores() {
        // The computed properties `overallHealthScore` and `riskSummary`
        // already provide a dynamic calculation. If persistent storage is needed
        // for these, they would be stored here.
        // For now, this method can trigger re-evaluation or logging.
        print("Digital Twin Health Score: \(overallHealthScore)")
        print("Digital Twin Risk Summary: \(riskSummary)")
    }

    /// Creates a snapshot of the current digital twin state for versioning.
    func createSnapshot() -> DigitalTwin {
        return self // A simple copy for now, more complex versioning would involve deep copying or serialization
    }

    /// Queries the digital twin for specific health insights.
    func queryHealthInsight(for type: HealthInsightType) -> String {
        switch type {
        case .sleepQuality:
            return "Your average sleep duration is \(String(format: "%.1f", lifestyleData.averageSleepDuration / 3600)) hours with \(String(format: "%.1f", lifestyleData.deepSleepPercentage))% deep sleep."
        case .cardiovascularHealth:
            return "Your average resting heart rate is \(String(format: "%.0f", biometricData.restingHeartRate.last ?? 0)) bpm. HRV trends are \(biometricData.heartRateVariability.last ?? 0 > 40 ? "good" : "fair")."
        case .stressManagement:
            return "Your recent stress levels indicate a need for mindfulness. Consider a 10-minute meditation."
        case .activityLevel:
            return "You've averaged \(lifestyleData.dailySteps.last ?? 0) steps per day this week."
        case .overallWellness:
            return "Your overall health score is \(String(format: "%.0f", overallHealthScore)). \(riskSummary)"
        }
    }
}

// MARK: - Sub-structures for Data Organization

/// A profile of the user's biometric data (e.g., HRV, RHR, SpO2).
struct BiometricProfile: Codable {
    var heartRate: [Double] // Added
    var heartRateVariability: [Double]
    var restingHeartRate: [Double]
    var bloodOxygenSaturation: [Double]
    var respiratoryRate: [Double] // Added
    var bodyTemperature: [Double] // Added
    var bloodPressureSystolic: [Double] // Added
    var bloodPressureDiastolic: [Double] // Added
    var bloodGlucose: [Double] // Added
    var weight: [Double] // Added
    var height: [Double] // Added
    var bodyMassIndex: [Double] // Added
    var bodyFatPercentage: [Double] // Added

    init(heartRate: [Double] = [], heartRateVariability: [Double] = [], restingHeartRate: [Double] = [], bloodOxygenSaturation: [Double] = [], respiratoryRate: [Double] = [], bodyTemperature: [Double] = [], bloodPressureSystolic: [Double] = [], bloodPressureDiastolic: [Double] = [], bloodGlucose: [Double] = [], weight: [Double] = [], height: [Double] = [], bodyMassIndex: [Double] = [], bodyFatPercentage: [Double] = []) {
        self.heartRate = heartRate
        self.heartRateVariability = heartRateVariability
        self.restingHeartRate = restingHeartRate
        self.bloodOxygenSaturation = bloodOxygenSaturation
        self.respiratoryRate = respiratoryRate
        self.bodyTemperature = bodyTemperature
        self.bloodPressureSystolic = bloodPressureSystolic
        self.bloodPressureDiastolic = bloodPressureDiastolic
        self.bloodGlucose = bloodGlucose
        self.weight = weight
        self.height = height
        self.bodyMassIndex = bodyMassIndex
        self.bodyFatPercentage = bodyFatPercentage
    }

    mutating func merge(with other: BiometricProfile) {
        self.heartRate.append(contentsOf: other.heartRate)
        self.heartRateVariability.append(contentsOf: other.heartRateVariability)
        self.restingHeartRate.append(contentsOf: other.restingHeartRate)
        self.bloodOxygenSaturation.append(contentsOf: other.bloodOxygenSaturation)
        self.respiratoryRate.append(contentsOf: other.respiratoryRate)
        self.bodyTemperature.append(contentsOf: other.bodyTemperature)
        self.bloodPressureSystolic.append(contentsOf: other.bloodPressureSystolic)
        self.bloodPressureDiastolic.append(contentsOf: other.bloodPressureDiastolic)
        self.bloodGlucose.append(contentsOf: other.bloodGlucose)
        self.weight.append(contentsOf: other.weight)
        self.height.append(contentsOf: other.height)
        self.bodyMassIndex.append(contentsOf: other.bodyMassIndex)
        self.bodyFatPercentage.append(contentsOf: other.bodyFatPercentage)
    }
}

/// A profile of the user's genomic data (e.g., genetic markers).
struct GenomicProfile: Codable {
    var geneticMarkers: [String: String] // e.g., ["rs12345": "A/G"]
    var rawGenomicData: Data? // Store raw data if needed
    var variantInterpretations: [String: String] // e.g., ["BRCA1": "Increased Breast Cancer Risk"]
    var riskAlleles: [String] // List of identified risk alleles

    init(geneticMarkers: [String : String] = [:], rawGenomicData: Data? = nil, variantInterpretations: [String : String] = [:], riskAlleles: [String] = []) {
        self.geneticMarkers = geneticMarkers
        self.rawGenomicData = rawGenomicData
        self.variantInterpretations = variantInterpretations
        self.riskAlleles = riskAlleles
    }
}

/// A profile of the user's clinical data (e.g., lab results).
struct ClinicalProfile: Codable {
    var labResults: [String: String] // e.g., ["Cholesterol": "200 mg/dL"]
    var diagnoses: [String] // e.g., ["Type 2 Diabetes"]
    var medications: [String] // e.g., ["Metformin"]
    var immunizations: [String] // e.g., ["Flu Shot 2023"]
    var allergies: [String] // e.g., ["Penicillin"]
    var hospitalizations: [HospitalizationRecord] // Added
    var procedures: [ProcedureRecord] // Added

    init(labResults: [String : String] = [:], diagnoses: [String] = [], medications: [String] = [], immunizations: [String] = [], allergies: [String] = [], hospitalizations: [HospitalizationRecord] = [], procedures: [ProcedureRecord] = []) {
        self.labResults = labResults
        self.diagnoses = diagnoses
        self.medications = medications
        self.immunizations = immunizations
        self.allergies = allergies
        self.hospitalizations = hospitalizations
        self.procedures = procedures
    }
}

/// A profile of the user's lifestyle data (e.g., sleep, exercise).
struct LifestyleProfile: Codable {
    var averageSleepDuration: TimeInterval
    var weeklyExerciseMinutes: Int
    var sleepDurations: [TimeInterval] // Added for historical sleep
    var deepSleepPercentage: Double // Added
    var remSleepPercentage: Double // Added
    var dailySteps: [Int] // Added for historical steps
    var caloriesBurned: [Double] // Added for historical calories
    var nutritionIntake: [NutritionEntry] // Added
    var stressLevels: [Double] // Added
    var mindfulnessMinutes: [Int] // Added
    var moodScores: [Double] // Added

    init(averageSleepDuration: TimeInterval = 0, weeklyExerciseMinutes: Int = 0, sleepDurations: [TimeInterval] = [], deepSleepPercentage: Double = 0, remSleepPercentage: Double = 0, dailySteps: [Int] = [], caloriesBurned: [Double] = [], nutritionIntake: [NutritionEntry] = [], stressLevels: [Double] = [], mindfulnessMinutes: [Int] = [], moodScores: [Double] = []) {
        self.averageSleepDuration = averageSleepDuration
        self.weeklyExerciseMinutes = weeklyExerciseMinutes
        self.sleepDurations = sleepDurations
        self.deepSleepPercentage = deepSleepPercentage
        self.remSleepPercentage = remSleepPercentage
        self.dailySteps = dailySteps
        self.caloriesBurned = caloriesBurned
        self.nutritionIntake = nutritionIntake
        self.stressLevels = stressLevels
        self.mindfulnessMinutes = mindfulnessMinutes
        self.moodScores = moodScores
    }

    mutating func merge(with other: LifestyleProfile) {
        self.averageSleepDuration = (self.averageSleepDuration + other.averageSleepDuration) / 2 // Simple average
        self.weeklyExerciseMinutes += other.weeklyExerciseMinutes
        self.sleepDurations.append(contentsOf: other.sleepDurations)
        self.dailySteps.append(contentsOf: other.dailySteps)
        self.caloriesBurned.append(contentsOf: other.caloriesBurned)
        self.nutritionIntake.append(contentsOf: other.nutritionIntake)
        self.stressLevels.append(contentsOf: other.stressLevels)
        self.mindfulnessMinutes.append(contentsOf: other.mindfulnessMinutes)
        self.moodScores.append(contentsOf: other.moodScores)
        // Recalculate percentages if needed
        self.deepSleepPercentage = (self.deepSleepPercentage + other.deepSleepPercentage) / 2
        self.remSleepPercentage = (self.remSleepPercentage + other.remSleepPercentage) / 2
    }
}

/// A profile of the user's environmental context (e.g., air quality, pollen).
struct EnvironmentalProfile: Codable {
    var airQualityIndex: Int
    var pollenCount: Int
    var uvIndex: Int // Added
    var noiseLevels: [Double] // Added
    var ambientLightLevels: [Double] // Added
    var airQualityReadings: [Int] // Added for historical
    var pollenCounts: [Int] // Added for historical

    init(airQualityIndex: Int = 0, pollenCount: Int = 0, uvIndex: Int = 0, noiseLevels: [Double] = [], ambientLightLevels: [Double] = [], airQualityReadings: [Int] = [], pollenCounts: [Int] = []) {
        self.airQualityIndex = airQualityIndex
        self.pollenCount = pollenCount
        self.uvIndex = uvIndex
        self.noiseLevels = noiseLevels
        self.ambientLightLevels = ambientLightLevels
        self.airQualityReadings = airQualityReadings
        self.pollenCounts = pollenCounts
    }

    mutating func merge(with other: EnvironmentalProfile) {
        self.airQualityReadings.append(contentsOf: other.airQualityReadings)
        self.pollenCounts.append(contentsOf: other.pollenCounts)
        self.noiseLevels.append(contentsOf: other.noiseLevels)
        self.ambientLightLevels.append(contentsOf: other.ambientLightLevels)
        // Simple average for current index/count
        self.airQualityIndex = (self.airQualityIndex + other.airQualityIndex) / 2
        self.pollenCount = (self.pollenCount + other.pollenCount) / 2
        self.uvIndex = (self.uvIndex + other.uvIndex) / 2
    }
}

// MARK: - Supporting Types

struct HealthPrediction: Codable {
    enum PredictionType: String, Codable {
        case cardiovascularDisease = "Cardiovascular Disease"
        case diabetesRisk = "Diabetes Risk"
        case sleepDisorder = "Sleep Disorder"
        case mentalHealthIssue = "Mental Health Issue"
        case infectiousDisease = "Infectious Disease"
        case nutritionalDeficiency = "Nutritional Deficiency"
        case injuryRisk = "Injury Risk"
        case overallHealthTrend = "Overall Health Trend"
    }

    enum RiskLevel: String, Codable, Comparable {
        case low = "Low"
        case moderate = "Moderate"
        case high = "High"
        case critical = "Critical"

        static func < (lhs: RiskLevel, rhs: RiskLevel) -> Bool {
            return lhs.rawValue < rhs.rawValue
        }
    }

    let type: PredictionType
    let riskLevel: RiskLevel
    let confidence: Double // 0-1 scale
    let timestamp: Date
    let details: String
    var recommendedActions: [String]? // Added

    init(type: PredictionType, riskLevel: RiskLevel, confidence: Double, timestamp: Date, details: String, recommendedActions: [String]? = nil) {
        self.type = type
        self.riskLevel = riskLevel
        self.confidence = confidence
        self.timestamp = timestamp
        self.details = details
        self.recommendedActions = recommendedActions
    }
}

struct HospitalizationRecord: Codable {
    let admissionDate: Date
    let dischargeDate: Date?
    let reason: String
    let diagnosis: String
    let procedures: [String]
}

struct ProcedureRecord: Codable {
    let date: Date
    let name: String
    let type: String // e.g., "Surgery", "Diagnostic"
    let outcome: String?
}

struct NutritionEntry: Codable {
    let date: Date
    let calories: Double
    let protein: Double
    let carbs: Double
    let fat: Double
    let waterIntake: Double
    let mealType: String // e.g., "Breakfast", "Lunch", "Dinner", "Snack"
}

enum HealthInsightType: String, Codable {
    case sleepQuality = "Sleep Quality"
    case cardiovascularHealth = "Cardiovascular Health"
    case stressManagement = "Stress Management"
    case activityLevel = "Activity Level"
    case overallWellness = "Overall Wellness"
}

// Example query usage with SwiftData
func fetchDigitalTwin(forUserID userID: String, in context: ModelContext) -> DigitalTwin? {
    @Query(filter: #Predicate<DigitalTwin> { twin in
        twin.userID == userID
    }) var twins: [DigitalTwin]
    return twins.first
}